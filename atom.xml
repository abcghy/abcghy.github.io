<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harry&#39;s Blog</title>
  
  <subtitle>Solid stuff</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abcghy.github.io/"/>
  <updated>2018-10-28T08:13:42.474Z</updated>
  <id>http://abcghy.github.io/</id>
  
  <author>
    <name>高惠宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git Merge 和 Rebase 的用法</title>
    <link href="http://abcghy.github.io/2017/04/20/Git-Merge-And-Rebase/"/>
    <id>http://abcghy.github.io/2017/04/20/Git-Merge-And-Rebase/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2018-10-28T08:13:42.474Z</updated>
    
    <content type="html"><![CDATA[<p>最近在找工作，总是会问到 merge 和 rebase 的区别，今天就写一篇文章整理一下 rebase 的用法。</p><p>这是一篇新手向的 rebase 初级用法教学，目的在于手把手的教会大家如何使 graph 变成线性，也可以在代码审查的时候，更容易理解大家所做的工作。<br><a id="more"></a></p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>关于rebase的用法，已经有很多文章了，我在这里就不班门弄斧了。例如：<br><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">Merging vs. Rebasing - Atlassian tutorials</a></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>首先我们假设有两个程序员进行协同工作，一个是你自己，一个是小高。</p><h3 id="初始化内容"><a href="#初始化内容" class="headerlink" title="初始化内容"></a>初始化内容</h3><p>本地创建一个 git 仓库。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>默认是 master 分支。</p><p>我们创建一个文件<code>README.md</code>并往里面添加一些内容：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Git Rebase Demo</span></span><br><span class="line">This is a rebase demo.</span><br></pre></td></tr></table></figure></p><p>之后将代码提交，以保证初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"init"</span></span><br></pre></td></tr></table></figure></p><p>此时 SourceTree 上看起来是这样的：<img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwnvwlcu9tj31kw10ewvp.jpg" alt="初始化时的样子"></p><p>接下来我和小高都会根据 master 分支来完成自己的任务。</p><h3 id="我的分支"><a href="#我的分支" class="headerlink" title="我的分支"></a>我的分支</h3><p>首先新建我的分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b myname</span><br></pre></td></tr></table></figure></p><p>然后做自己的工作，比如添加一段话：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Git Rebase Demo</span></span><br><span class="line">This is a rebase demo.</span><br><span class="line"></span><br><span class="line"><span class="section">## myname</span></span><br><span class="line">This is the work that I done.</span><br></pre></td></tr></table></figure></p><p>然后保存提交<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"myname's work"</span></span><br></pre></td></tr></table></figure></p><p>这样，我们就完成了我们的工作。</p><p>接下来按照同样的操作，添加一个小高的分支</p><h3 id="模拟小高的操作"><a href="#模拟小高的操作" class="headerlink" title="模拟小高的操作"></a>模拟小高的操作</h3><p>回到 master 分支，新建小高分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b xiaogao</span><br></pre></td></tr></table></figure></p><p>然后同样的添加一段话<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Git Rebase Demo</span></span><br><span class="line">This is a rebase demo.</span><br><span class="line"></span><br><span class="line"><span class="section">## xiaogao</span></span><br><span class="line">This is xiaogao's work.</span><br></pre></td></tr></table></figure></p><p>接着保存小高的工作成果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"xiaogao's work"</span></span><br></pre></td></tr></table></figure></p><p>现在， SourceTree 上的图是这样的： <img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnvzbwqx7j31kw10e7mg.jpg" alt="两个人都完成工作之后"></p><h3 id="小高先提交自己的代码"><a href="#小高先提交自己的代码" class="headerlink" title="小高先提交自己的代码"></a>小高先提交自己的代码</h3><p>由于小高速度比较快，所以他先提交了自己的代码。因为他是直接从公共分支(master)checkout出来的，并且后来master分支也没有合并新的代码，所以小高可以直接使用 merge 的方式讲代码合并进 master 分支。<br>我们先切换成 master 分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge xiaogao</span><br></pre></td></tr></table></figure></p><p>此时为这样：<img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwnw2l0ug9j31kw10eas2.jpg" alt="在 master 分支中，合并小高的分支"><br>master 和小高分支同步了。</p><h3 id="关键的-rebase"><a href="#关键的-rebase" class="headerlink" title="关键的 rebase"></a>关键的 rebase</h3><p>我们大可以用 merge 来将自己的工作合并到 master 分支当中（当然得处理冲突），但是这样的话， graph 就会不清晰。如果用 rebase 的话，graph 就会呈现为线性，更加容易理解。</p><h4 id="尝试用-merge"><a href="#尝试用-merge" class="headerlink" title="尝试用 merge"></a>尝试用 merge</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge myname</span><br><span class="line"></span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>可以看出，发生了冲突：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Git Rebase Demo</span></span><br><span class="line">This is a rebase demo.</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">## xiaogao</span><br><span class="line">This is xiaogao's work.</span><br><span class="line">=======</span><br><span class="line">## myname</span><br><span class="line">This is the work that I done.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; myname</span><br></pre></td></tr></table></figure></p><p>这篇文章不详细说明如何解决冲突，只是简单处理当前冲突。</p><p>我们将 <code>&lt;&lt;&lt; === &gt;&gt;&gt;</code> 这些符号以及后面的文字都去掉，变成这样：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Git Rebase Demo</span></span><br><span class="line">This is a rebase demo.</span><br><span class="line"></span><br><span class="line"><span class="section">## xiaogao</span></span><br><span class="line">This is xiaogao's work.</span><br><span class="line"></span><br><span class="line"><span class="section">## myname</span></span><br><span class="line">This is the work that I done.</span><br></pre></td></tr></table></figure></p><p>这样的话，两个人的工作成果都保存了下来，小高的在前，你的在后。于是我们保存一下处理冲突之后的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"merge myname to master"</span></span><br></pre></td></tr></table></figure></p><p>使用 merge 是不是太简单了，只需要处理冲突之后保存就好，省去了很多不必要的麻烦。但是这个时候我们看看 SourceTree: <img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwnwkplzwuj31kw10eh4j.jpg" alt="merge 之后"><br>但是 graph 当中，有一个从初始化之后进行的分叉，最后合到 master 分支之后又有一次 commit 信息，如果只是两人协作或者只有两个子分支协作倒是不是很复杂，但是如果你是和四五个人同时协作，并且每个人都有自己的 feature 分支、 hotfix 分支，总共十几二十个分支的话，那么 merge 之后的 graph 界面只能说是惨不忍睹！</p><p>下面贴一个很久之前工作团队只使用 merge 的一个例子：<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwnyrh0jthj31kw0wxwsn.jpg" alt="多人合作就很复杂">从这样的提交历史当中，已经很难看出谁加了什么功能，graph 也是杂乱无章。 </p><h4 id="用今天的主角，rebase"><a href="#用今天的主角，rebase" class="headerlink" title="用今天的主角，rebase"></a>用今天的主角，rebase</h4><p>我们重新回滚到merge之前的代码状态。<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnz4g3h73j31kw0x4qtl.jpg" alt="回滚的操作"><br>选择 hard，点击确定就回到了 merge 之前的状态。</p><p>rebase 首先需要切换到 myname 分支下，接着 rebase<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout myname</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure></p><p>毫无疑问，还是会出现冲突，按照刚才解决冲突的方法再执行一遍。然后保存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></p><p>注意这里是 <code>git rebase --continue</code> 而不是 commit，完成之后我们会看到 SourceTree 里我们的 graph 就变得很清爽了：<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnza2d8i0j31kw0yu4kq.jpg" alt="rebase后的 graph"></p><p>最后，你需要回到 master 分支，merge myname 分支，并且清理其他无用分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge myname</span><br><span class="line">git branch -d myname</span><br><span class="line">git branch -d xiaogao</span><br></pre></td></tr></table></figure></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwnzine1lcj31kw0yu1em.jpg" alt="最终效果">这里的 graph 就呈现线性的状态，非常的清爽。相比 merge 操作，少了一个分叉，也少了一个 merge 的 commit。沿着 graph 一个一个往下观察，可以清晰的看到每个人的每一步操作。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>merge 和 rebase 虽然都是将一个分支的代码合并进另一个分支，但是他们的理念不同，所以所在分支也不一样，操作的时候需要注意。</p><p>切记，rebase 操作不要在公共分支上进行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章虽然简单，但是熟练之后运用到自己的项目中会非常的有用。前半部分先告诉大家如何模拟多人协作，后面告诉大家 merge 和 rebase 的区别。</p><p>我建议大家不只是单纯的看一遍文章，就觉得理解了rebase的基本用法，还是跟着文章敲一遍，甚至是自己动手做个小demo比较好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在找工作，总是会问到 merge 和 rebase 的区别，今天就写一篇文章整理一下 rebase 的用法。&lt;/p&gt;
&lt;p&gt;这是一篇新手向的 rebase 初级用法教学，目的在于手把手的教会大家如何使 graph 变成线性，也可以在代码审查的时候，更容易理解大家所做的工作。&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://abcghy.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>TinkerPatch 最简单的接入方案</title>
    <link href="http://abcghy.github.io/2017/02/25/Tinker-Patch-Tutorial/"/>
    <id>http://abcghy.github.io/2017/02/25/Tinker-Patch-Tutorial/</id>
    <published>2017-02-24T16:00:00.000Z</published>
    <updated>2018-10-28T07:51:22.997Z</updated>
    
    <content type="html"><![CDATA[<p>天天埋头做业务的你，是不是会经常听到下面一些话：“完了，xx页面的文案忘了改了”。由于初创公司的开发流程不完善，可能会导致各种各样的问题，甚至在 app 上线之后，立马就会找到一个 bug。如何避免这种情况呢？Hotfix 可能是目前比较成熟的一个方案。<br><a id="more"></a></p><h2 id="什么是-TinkerPatch"><a href="#什么是-TinkerPatch" class="headerlink" title="什么是 TinkerPatch"></a>什么是 TinkerPatch</h2><p>你可能听过 <a href="https://github.com/Tencent/tinker" target="_blank" rel="noopener">Tinker</a> ， 以 Dota 中的<a href="http://www.dota2.com.cn/hero/tinker/" target="_blank" rel="noopener">修补匠</a>命名，是腾讯团队出的一个热修补框架，能够在不更新新的安装包的情况下对 app 进行修复。但是 Tinker 需要你自己有一个服务器，并且有相应的后台机制，这对初创公司来说可能是一个非常难以实现的要求。<br>所以， TinkerPatch 就出现了。它使用七牛 CDN 对开发者上传的补丁进行加速，开发者无需自己搭建后台，就可以享受热修补带来的方便。当然， TinkerPatch 目前是免费的，以后是否会收费也从来没有说明过，但我想说的是，如此好用的平台，就算以后收费了，也是值得继续使用的。更何况腾讯将 <a href="https://github.com/baidao/tinker-manager" target="_blank" rel="noopener">server 端</a>也开源了，不过据说没有 TinkerPatch 的一键接入好用。</p><h2 id="SDK-接入"><a href="#SDK-接入" class="headerlink" title="SDK 接入"></a>SDK 接入</h2><p>如果你想快速上手热修补，想快速做出一个 Demo 查看成果，是无须知道 Tinker 相关事宜的。当然，在入门之后深入了解 Tinker 还是非常有必要的。官方的开发文档<br><a href="http://tinkerpatch.com/Docs/SDK" target="_blank" rel="noopener">TinkerPatch SDK 接入</a>比较详细，但是还是有一些让人觉得不太清楚，我会详细的将每一步都说明出来。</p><h3 id="注册-Tinker-Platform"><a href="#注册-Tinker-Platform" class="headerlink" title="注册 Tinker Platform"></a>注册 Tinker Platform</h3><p>首先得<a href="http://tinkerpatch.com/Index/reg" target="_blank" rel="noopener">注册</a>一个账号，在验证邮箱之后，会进入 App 管理页面，点击新增 APP <img src="https://ww2.sinaimg.cn/large/006tNbRwly1fd2h4myjsaj30g80msdg5.jpg" alt="新增 APP"> ，输入 Demo 的名字，叫 <code>TinkerPatchDemo</code> 好了。之后进入此 app 的管理页面，左边的 appKey 是之后要放入 <code>tinkerpatch.gradle</code> 里的参数，右边可以为某一版本添加补丁。左下角还有一些其他功能，我们暂时不需要用到它们。<br><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fd2jd6yrlyj30yy0ywgnn.jpg" alt=""></p><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p>首先告诉大家，我已经将该 demo 的源码上传至<a href="https://github.com/abcghy/TinkerPatchDemo" target="_blank" rel="noopener">TinkerPatchDemo</a> ，有的地方不清楚的可以看源码，实在不清楚的可以在评论区提交问题。<br>打开 Android Studio ，新建一个名为 <code>TinkerPatchDemo</code> 的项目。进入之后先将项目架构由 Android 改为 Project 以便于我们的操作。<img src="https://ww1.sinaimg.cn/large/006tNbRwly1fd2hcezy5uj30ds0h075d.jpg" alt=""><br>在项目根目录中的 <a href="https://ww3.sinaimg.cn/large/006tNbRwly1fd2hh7hqnzj30gg0is0u9.jpg" target="_blank" rel="noopener"><code>gradle.properties</code></a> 文件中设置我们 Tinker, TinkerPatch 的版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TINKER_VERSION=1.7.7</span><br><span class="line">TINKERPATCH_VERSION=1.1.3</span><br></pre></td></tr></table></figure><p>接着，在根目录的 <a href="https://ww3.sinaimg.cn/large/006tNbRwly1fd2hksvjojj30ki0lqgnc.jpg" target="_blank" rel="noopener"><code>build.gradle</code></a> 添加</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="comment">//无需再单独引用tinker的其他库</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:$&#123;TINKERPATCH_VERSION&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，进入 app 的目录，找到 <code>build.gradle</code> ，添加几个 dependencies，并在最后添加 <code>apply from: &#39;tinkerpatch.gradle&#39;</code>。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">//********</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"com.android.support:multidex:1.0.1"</span></span><br><span class="line">    <span class="comment">//若使用annotation需要单独引用,对于tinker的其他库都无需再引用</span></span><br><span class="line">    provided(<span class="string">"com.tencent.tinker:tinker-android-anno:$&#123;TINKER_VERSION&#125;"</span>) &#123; changing = <span class="keyword">true</span> &#125;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"com.tinkerpatch.sdk:tinkerpatch-android-sdk:$&#123;TINKERPATCH_VERSION&#125;"</span>) &#123; changing = <span class="keyword">true</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="keyword">from</span>: <span class="string">'tinkerpatch.gradle'</span></span><br></pre></td></tr></table></figure><p>这个时候就遇到刚才的提到的 <code>tinkerpatch.gradle</code> 了，这是什么呢？它很显然是一个 gradle 文件，里面包含了 tinkerpatch 的各个参数，对于里面的各项参数是什么意思，官网都给出了<a href="http://tinkerpatch.com/Docs/SDK" target="_blank" rel="noopener">答案</a>，我就不费口舌了，不过在咱们的 demo 里面是不需要仔细知道各个参数的意义的，你可以直接从 <a href="https://github.com/abcghy/TinkerPatchDemo/blob/master/app/tinkerpatch.gradle" target="_blank" rel="noopener">我的源码</a>里下载该文件。下载完之后，放入 app 目录里，并将刚刚得到的 appKey 填入。<br><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fd2hu0cabqj30tw0cqjtb.jpg" alt=""><br>这里会看到一个变量叫 <code>appVersion</code> ，这个东西比较重要，你需要知道的是，这个变量和你的 app 本身的那个 <code>versionCode</code> 是没有什么关系的，它只是表示了和补丁相关的版本，你在热修补的时候，可以不升级 <code>versionCode</code> 但是一定要升级 <code>appVersion</code> ，否则在升级的时候会出现一些 bug ，比如升级到老版本补丁这种情况。<br>当然，我们现在不需要改变 <code>appVersion</code> 就让他为 <code>1.0.0</code> 好了。以上弄完了就可以点击右上角的 <code>Sync Now</code>了。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>首先新建一个 Application 类作为该项目的 Application ，我取名为 <code>App</code> ,之后在 AndroidManifest 里修改。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".App"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>你可以直接从<a href="https://github.com/abcghy/TinkerPatchDemo/tree/master/app/src/main/java/com/gaohuiyu/tinkerpatchdemo" target="_blank" rel="noopener">我的源码</a>中，复制该类和 <code>FetchPatchHandler</code> 类，具体的用法可以直接参考官方文档，由于我们是快速实现demo就不解释 API 了。那么到这里为止，基本的 sdk 就已经接入完成，接下来就是如何构建补丁包和上传热修补补丁了。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>不得不说这一步骤官方文档说的很不清晰，我摸索了一下才摸索出来，希望我的配图可以使你了解该过程。</p><h3 id="老版本"><a href="#老版本" class="headerlink" title="老版本"></a>老版本</h3><p>为了分辨老版本和新版本，我们将老版本的 <code>activity_main.xml</code> 中的 <code>Hello World</code> 改为 <code>1.0.0老版本</code>。点击调试按钮，在真机上装上这第一个版本。<br><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fd2jpe5wimj30do05w3yz.jpg" alt=""><br>等待安装完毕，你的手机上应该只有一个空荡荡的 <code>TextView</code> 上面写着 <code>1.0.0老版本</code>，那么就对了。这时候看 as 中的项目架构，打开 <code>app/build/bakApk</code> 里面会有一个文件夹，打开它会看到 debug 文件夹，再里面就是debug的apk和R.txt文件了。<br><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fd2ju7yhtwj30mw0l4gnp.jpg" alt=""><br>接下来，打开之前所说的 <code>tinkerpatch.gradle</code>文件，找到</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> baseInfo = <span class="string">"app-0115-23-11-20"</span></span><br><span class="line"><span class="keyword">def</span> variantName = <span class="string">"debug"</span></span><br></pre></td></tr></table></figure><p>这两行，复制 baseinfo 里的字符串，在 bakApk 里新建一个文件夹，名字就叫 <code>app-0115-23-11-20</code>，然后再在该文件夹里新建一个文件夹名字叫 <code>debug</code>，之后再将刚才得到的两个文件复制进去。如图：<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fd2jy7d9aqj30nq0iy40h.jpg" alt=""></p><h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p>复制好了之后，就是开始新版本的构建工作了，我们先将 <code>activity_main.xml</code> 中的文字改成 <code>1.0.1 新版本</code> ，你也可以增加一些其他的特性，在这里我们只是突显出区别。然后将 <code>tinkerpatch.gradle</code> 中的 <code>appVersion</code> 改为 <code>1.0.1</code> 。<br>打开右边的 gradle 页面，找到 app 里 tinker 中的 <code>tinkerPatchDebug</code>，双击运行。<br><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fd2ktp6xe4j30n20madi2.jpg" alt=""><br>我们可以看到 bakApk 里又多了一个 1.0.1的文件夹。tinkerpatch 根据我们提供的旧版本和当时编译的新版本进行判断，然在 <code>app/build/outputs/tinkerPatch/debug/</code> 后生成一些补丁包。<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fd2lkkogi6j30lk0qkgnt.jpg" alt=""><br>这个补丁包就是我们要上传的补丁包。</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>打开 <a href="http://tinkerpatch.com/Apps/index" target="_blank" rel="noopener">我的app</a> 进入你刚才生成的 app，点击添加app版本，输入老版本的 <code>appVersion</code> 也就是 <code>1.0.0</code> 。点击生成的版本号，会进入发布补丁的页面，这时候找到 <code>patch_signed_7zip.apk</code> 提交就可以了。需要注意的是，有的运营商可能会对 <code>*.apk</code> 文件进行一个拦截，所以官方建议修改后缀名，我的运营商并没有干这种事情，所以我就没有改后缀名了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>既然补丁包都上传了，我们总得看看成不成功了吧？值得一提的是，tinkerpatch 并不是直接就会生效的，根据 <code>App</code> 里的设定，是每隔三个小时查看一次后台，这样比较省流量也不会消耗电量。<br>为了快速的查看是否成功，我们将该 app 从后台杀掉，再次进入，这个时候他就会访问七牛 CDN 看看有没有补丁包了。获取到了之后并不会立即生效，我们可以关闭屏幕，或者退出 app 再进，就可以看到新的 app <code>1.0.1新版本</code>了。<br><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fd2lvz7b4ej30u01hct9g.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章写了一些简单的接入，目的是为了让广大没有接触过 Tinker 的吃瓜群众更快的上手热修补，可能后续还会写一些深入的文章，比如说如何打 realease 包，如何定制化的实现 tinker 的功能，如何自己搭建 tinker 后端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天天埋头做业务的你，是不是会经常听到下面一些话：“完了，xx页面的文案忘了改了”。由于初创公司的开发流程不完善，可能会导致各种各样的问题，甚至在 app 上线之后，立马就会找到一个 bug。如何避免这种情况呢？Hotfix 可能是目前比较成熟的一个方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="Hotfix" scheme="http://abcghy.github.io/tags/Hotfix/"/>
    
      <category term="Tinker" scheme="http://abcghy.github.io/tags/Tinker/"/>
    
      <category term="Android" scheme="http://abcghy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio proxy 设置</title>
    <link href="http://abcghy.github.io/2016/07/16/Android-Studio-Proxy-Setting/"/>
    <id>http://abcghy.github.io/2016/07/16/Android-Studio-Proxy-Setting/</id>
    <published>2016-07-15T16:00:00.000Z</published>
    <updated>2018-10-28T07:51:22.997Z</updated>
    
    <content type="html"><![CDATA[<p>广大程序员都知道，由于特殊的地理优势，在访问 jcenter 的时候，不科学上网是不行的。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>平时我使用科学上网的工具是 shadowsocks ，不知道 ss 的朋友可以去搜搜 ss 是什么。在我开启了全局模式之后，Android Studio 也是不会自动连接外网的。后来查到在 <code>Preferences/Appearance &amp; Behavior/System Settings/HTTP Proxy</code> 里手动设置<br><img src="https://ww2.sinaimg.cn/large/006tKfTcly1fd48qvkebzj31kw113jy3.jpg" alt=""><br>这样也是没有效果的！<br>最后终于找到了方法，在项目根目录下的 <code>gradle.properties</code> 里加入  <code>org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080</code> ，然后进行 <code>sync</code>，完美解决问题！</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>顺便附上在 iterm2 里进行代理的命令行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=socks5://127.0.0.1:1080</span><br><span class="line">export https_proxy=$http_proxy</span><br></pre></td></tr></table></figure><p>每次想设置 proxy 就复制一下就行了。如果不想那么麻烦，就写入 <code>.zshrc</code> 里好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;广大程序员都知道，由于特殊的地理优势，在访问 jcenter 的时候，不科学上网是不行的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Proxy" scheme="http://abcghy.github.io/tags/Proxy/"/>
    
      <category term="Android Studio" scheme="http://abcghy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
</feed>
